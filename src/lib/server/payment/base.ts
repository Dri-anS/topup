import { z } from "zod";

export type TransactionStatus = "UNPAID" | "PAID" | "EXPIRED" | "FAILED" | "REFUND";

export const TransactionItemSchema = z.object({
	id: z.string(),
	price: z.number(),
	quantity: z.number(),
	name: z.string().optional(),
	brand: z.string().optional(),
	category: z.string().optional(),
	url: z.string().optional()
});

export const TransactionSchema = z.object({
	id: z.string(),
	transactionId: z.string().optional(),
	transactionStatus: z.string().optional(),
	amount: z.number(),
	items: TransactionItemSchema.array(),
	customerName: z.string().optional(),
	customerEmail: z.string().optional(),
	customerPhone: z.string().optional(),

	paymentCode: z.string().optional(),
	paymentMethod: z.string(),

	callbackUrl: z.string().optional()
});

export interface Transaction {
	// id generated by server
	id: string;
	// transactionId generated by payment gateway
	transactionId?: string;
	transactionStatus?: TransactionStatus;
	// amount of transaction (include unique code)
	amount: number;
	// items
	items: TransactionItem[];
	customerName?: string;
	customerEmail?: string;
	customerPhone?: string;

	// qris url, va code
	paymentCode?: string;
	paymentMethod: string;

	// url for user callback
	callbackUrl?: string;
}

export interface TransactionWebhook {
	id: string;
	paymentMethod: string;
	transactionId: string;
	transactionStatus: TransactionStatus;
}

export interface TransactionItem {
	id: string;
	price: number;
	quantity: number;
	name?: string;
	brand?: string;
	category?: string;
	url?: string;
}

export interface Channel {
	code: string;
	name: string;
	group: string;
	feePercent: number;
	feeFlat: number;
}

export abstract class Payment {
	abstract readonly name: string;
	abstract verifyCallback(req: Request): Promise<TransactionWebhook>;
	abstract createTransaction(tx: Transaction): Promise<Transaction>;
	abstract getChannels(): Promise<Channel[]>;
}

export class PaymentError extends Error {}
